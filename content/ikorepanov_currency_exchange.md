## Ревью на проект [currency-exchange] (https://github.com/ikorepanov/currency-exchange)


### Плюсы

+ всё работает, возвращатся ожидаемые ответы и коды ошибок

+ присутствует валидация входных данных и обработка исключений

+ на все виды исключений сервиса написаны кастомные Exceptions

+ настроены линтеры в пре-коммите (так обычно во всех проектах рабочих сделано)

+ использование контестного менеджера для соединений к БД

+ защита от скл-инъекций через параметризованные запросы

+ хороший и понятный нейминг переменных, методов, классов

+ отправка ошибок единым методом с правильными кодами ошибок, в правильном формате, с логгированием


### Минусы

- SQL скрипты странно выглядят в файле с константами, вообще с ними как ни крути плохо - Python код и SQL код вместе писать нехорошо,
поэтому даже если их убрать из констант и оставить прямо в слое DAO, то будет также нехорошо. Самым лучшим вариантом вижу создать отдельную директорию
dao и в ней сложить модуль daos.py и файлик со скриптами. ещё как минус такого подхода - почти все скрипты используются ровно 1 раз в проекте,
обычно выносится в переменные или константы все, что используется 2 и более раз.

- не хватает строк документации к функциям и классам, это не обязательный к исполнению PEP, но всё же хороший тон
https://peps.python.org/pep-0257/
главное в строках документации - написать зачем нужна функция или класс, а не что оно делает

- в dao в методе interact_with_db используется аргумент "all", это имя зарезервировано в python под функцию all, лучше использовать имя
is_fetch_all или is_all по смыслу булева значения, на крайняк _all.
сама функция interact_with_db и выполняет запрос в базу и обрабатывает результаты, нарушен принцип единой ответственности

- метод _execute здесь же ни к каким методам или атрибутам класса не образается, поэтому это staticmethod

- константа GET_LAST_CREATED_ID_SQL = 'SELECT last_insert_rowid()' зачем вообще нужна? она усложняет нам метод interact_with_db
из-за это мы в цикле for перебираем скл-скрипты, чтобы вставить одну валюту надо выполнить два зарпоса получается
чтобы получить все валюты тоже два запроса. наверчено здесь вообщем.
а вернуть вставленную запись можно как-то сильно проще, вроде в SQLite есть ключевое слово RETURNING как в нормальных БД,
для вставки валюты будет добавить в запрос строчку "RETURNING id, code, name, sign", а если RETURNING там нет,
то брать айди новой записи через cur.lastrowid делать здесь же повторный запрос на получение данных по этому айди.
на крайний случай не трогать вообще этот айди, и брать по коду валюты - он у нас всегда уникален

- create_db - везде, где берутся данные по индексу желательно сначала убедиться, что данный индекс в объекте есть
это я про
code = csv_parts[0]
name = csv_parts[1]
sign = csv_parts[2]
и
base_cur_code = csv_parts[0]
target_cur_code = csv_parts[1]
rate_str = csv_parts[2]

если в списке меньше 3-х объектов, то вылетит keyerror

в этом примере тоже Currency(row[0], row[1], row[2], row[3]) и в остальных пободных случаях - это magic numbers,
хрупкая и потенциально опасная конструкция с обращением по индексу.
а при изменении структуры БД придется искать все места, где обращения по индексу и менять их, легко ошибиться
если в методе get_currency в переменную query_result прилетит None, то обращение по индексу будет фатальным,
поэтому обработку на такие случае лучше делать до попытки взять оттуда данные

- в классе сервиса метод exchange_currencies прям хороший пример антипаттерна: он делает слишком много, и поиск валют,
прямой и обратный курсы, кросс-курс, и обработка ошибок с вложенными try-except!
в идеале его разбить на разные методы, а внутри этого метода написать всего 3 строчки:
get_direct_exchange_rate(...) - если получили прямой курс, то вернем его
get_reverse_exchange_rate(...) - если получили обратный курс, то вернем через его
get_cross_exchange_rate(...) - если в первых двух ничего не получили, то ищем по USD конвертации
и в конце если ничего не нашли, то вернем ошибку

- частая ошибка в проекте с использованием переменной, которая могла быть не инициализирована ранее:
if currency.id is not None:
    id = currency.id
return CurrencyDto(id, currency.full_name, currency.code, currency.sign)
здесь условие if могло вернуть False и тогда переменная id не появляется, а в следующей строчке эту переменную во всю пытаемся использовать
вот тут тоже так
if currency_a.id is not None and currency_b.id is not None:
    currency_a_id = currency_a.id
    currency_b_id = currency_b.id

return CurrenciesInfo(currency_a, currency_b, currency_a_id, currency_b_id)
условие if не сработает и переменные currency_a_id, currency_b_id не будут инициализированы, но в return используются

- в методе get_rates() класса Service видится проблема N+1 запросов в БД:
сначала получаем все обменные курсы self.repository.get_rates()
потом отдельно по валютам ещё два запроса
self.repository.get_currency_by_id(rate.base_id),
self.repository.get_currency_by_id(rate.target_id),
можно это всё через джойны одним скл запросом получить все данные и потом сформировать нужную структуру

- в классе сервиса лучше не создавать объект репозиторий, это лишняя и ненужная ответственность для класса
@cached_property
def repository(self) -> Repository:
    return Repository()
его надо или просто импортировать или внедрять как DependecyInjection (DI)

- в контроллере do_GET реализован через множественные if-elif, если добавить новый маршрут, то туда же ещё один добавлять придется.
посмотри на вариант через маппинг со словарем например, ключем будет self.first_segment, а значением функция обработчик.
при добавлении нового пути в словарь добавим одну строчку и новую функцию обработчик, удобно.

- метод update_rate в контроллере такой же сложный и плохой как в слое сервиса: он слишком много всего выполняет,
имеет вложенную структуру, 7 уровней вложенности! явно требует оптимизации
тут тоже опасное обращение по индексам self.second_segment[:3] и self.second_segment[3:], а если длина second_segment 5 символов

- метод exchange в контроллере тоже перегружен разными действиями и уровнями вложенности, всего 5 уровней вложенности! в идеале 2-3, не более
в контроллере преобразование в Decimal не должно происходить, это все в сервсие должно выполняться

- текст ошибки "Код валюты должен состоять из 3 заглавных английских букв" используется в контроллере 4 раза - явно просится вынести его в константу



В целом чувствуется глубокая проработка проекта, но присутсвует перегрузка слоев лишним функционалом.
Все задачи можно решить меньшим колчичеством действий, не перегружая методы и не давай им лишней ответственности.
Самая проблема как раз в слое сервсиа в функции расчета конвертации валюты. Это ключевая деталь проекта.
И самая суть в том, чтобы сделать её просто. А в проекте это получилось с кучей if и вложенными try-except.

По паттерну MVCS. Модель - всё ок у тебя.
View - не нашел такого слоя вообще, его функции выполняет частично контроллер и частично сервис.
Контроллер должен делать меньше, чем сейчас, не должно быть только обработки в нем.
Сервис смешан с view логикой, есть перегруженные методы, но в целом он выполняет свою функцию, но и другие лишние функции тоже.

